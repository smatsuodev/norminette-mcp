// Based on norminette/lexer/dictionary.py

export const keywords: Record<string, string> = {
  // C reserved keywords
  'auto': 'AUTO',
  'break': 'BREAK',
  'case': 'CASE',
  'char': 'CHAR',
  'const': 'CONST',
  'continue': 'CONTINUE',
  'default': 'DEFAULT',
  'do': 'DO',
  'double': 'DOUBLE',
  'else': 'ELSE',
  'enum': 'ENUM',
  'extern': 'EXTERN',
  'float': 'FLOAT',
  'for': 'FOR',
  'goto': 'GOTO',
  'if': 'IF',
  'int': 'INT',
  'long': 'LONG',
  'register': 'REGISTER',
  'return': 'RETURN',
  'short': 'SHORT',
  'signed': 'SIGNED',
  'sizeof': 'SIZEOF',
  'static': 'STATIC',
  'struct': 'STRUCT',
  'switch': 'SWITCH',
  'typedef': 'TYPEDEF',
  'union': 'UNION',
  'unsigned': 'UNSIGNED',
  'void': 'VOID',
  'volatile': 'VOLATILE',
  'while': 'WHILE',
  'inline': 'INLINE',
  'NULL': 'NULL',
  'restrict': 'RESTRICT'
};

export const operators: Record<string, string> = {
  '>>=': 'RIGHT_ASSIGN',
  '<<=': 'LEFT_ASSIGN',
  '+=': 'ADD_ASSIGN',
  '-=': 'SUB_ASSIGN',
  '*=': 'MUL_ASSIGN',
  '/=': 'DIV_ASSIGN',
  '%=': 'MOD_ASSIGN',
  '&=': 'AND_ASSIGN',
  '^=': 'XOR_ASSIGN',
  '|=': 'OR_ASSIGN',
  '<=': 'LESS_OR_EQUAL',
  '>=': 'GREATER_OR_EQUAL',
  '==': 'EQUALS',
  '!=': 'NOT_EQUAL',
  '=': 'ASSIGN',
  ';': 'SEMI_COLON',
  ':': 'COLON',
  ',': 'COMMA',
  '.': 'DOT',
  '!': 'NOT',
  '-': 'MINUS',
  '+': 'PLUS',
  '*': 'MULT',
  '/': 'DIV',
  '%': 'MODULO',
  '<': 'LESS_THAN',
  '>': 'MORE_THAN',
  '...': 'ELLIPSIS',
  '++': 'INC',
  '--': 'DEC',
  '->': 'PTR',
  '&&': 'AND',
  '||': 'OR',
  '^': 'BWISE_XOR',
  '|': 'BWISE_OR',
  '~': 'BWISE_NOT',
  '&': 'BWISE_AND',
  '>>': 'RIGHT_SHIFT',
  '<<': 'LEFT_SHIFT',
  '?': 'TERN_CONDITION',
  '#': 'HASH'
};

export const brackets: Record<string, string> = {
  '{': 'LBRACE',
  '}': 'RBRACE',
  '(': 'LPARENTHESIS',
  ')': 'RPARENTHESIS',
  '[': 'LBRACKET',
  ']': 'RBRACKET'
};

// Sort operators by length (longest first) for greedy matching
export const sortedOperators = Object.keys(operators).sort((a, b) => b.length - a.length);